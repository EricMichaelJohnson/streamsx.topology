/*
# Licensed Materials - Property of IBM
# Copyright IBM Corp. 2015,2016
 */
namespace com.ibm.streamsx.topology.topic ;

/**
 * Publish a stream to a topic. Allows other IBM Streams
 * applications to subscribe to the input stream, including
 * those written in different languages.
 * See [namespace:com.ibm.streamsx.topology.topic] for details.
 * @input In Stream to be published as a topic.
 * @param topic Topic to publish stream to.
 * @param allowFilter True if filters can be pushed from
 *  subscribing SPL applications. Optional, defaults to `false`.
*/
public composite Publish(input In )
{
	param
		expression<rstring> $topic ;
        expression<boolean> $allowFilter : false;
	graph
		() as ExportTopic = Export(TopicProperties)
		{
                param
                  properties :
                  {
                     __spl_exportType = "__setup__"
                  };
                  allowFilter: $allowFilter;
		}
                stream<In> TopicProperties = Filter(In) {
                   logic state: int32 rc = setTopicNameProperties($topic, $allowFilter);
                }
}

stateful int32 setTopicNameProperties(rstring topicName, boolean allowFilter) {
   appTrc(spl::Trace.debug, "Setting Topic name:" + topicName);
   if (!checkTopicName(topicName)) {
       appLog(spl::Log.error, "Topic name is invalid:" + topicName);
       appTrc(spl::Trace.error, "Topic name is invalid:" + topicName);
       assert(true, "Topic name is invalid:" + topicName);
       return -1;
   }
   list<rstring> levels = tokenize(topicName, "/", true);
   
   int32 rc = setOutputPortExportProperties(
                  {
                     __spl_version = 3l,
                     __spl_exportType = "topic",
                     __spl_topic = topicName,
                     __spl_topicLevels = levels,
                     __spl_topicLevelCount = (int64) size(levels),
                     __spl_allowFilter = allowFilter ? "true" : "false",
                     __spl_channel = (int64) getChannel(),
                     __spl_maxChannels = (int64) getMaxChannels()
                  }, 0u);

   appTrc(spl::Trace.debug, "Set Topic name:" + topicName + " = " + (rstring) rc);
   if (rc != 0) {
       appLog(spl::Log.error, "Setting topic name failed:" + topicName + " rc=" + (rstring) rc);
       assert(true, "Setting topic name failed:" + topicName + " rc=" + (rstring) rc);
   }

   return rc;
}

/**
 * Subscribe to a topic.
 * Generates a stream that is subscribed, through
 * IBM Streams dynamic connections, to all streams
 * published to the same `topic` and `streamType`.
 * See [namespace:com.ibm.streamsx.topology.topic] for details.
 
 * @output Topic Subscription to `topic`.
 * @param topic Topic to subscribe to.
 * @param streamType Type of output stream `Topic`.
*/
public composite Subscribe(output Topic )
{
	param		
		expression<rstring> $topic ;
		type $streamType ;
	graph
         stream<$streamType> TopicImport = Import()
         {
           param
              // Initially match nothing, the initialization
              // of the no-op Filter sets the expression.
              subscription : __spl_exportType == "none";
         }

         // Use a Filter to dynamically set the subscription
         // expression based upon the UDP state of this invocation.
         stream<TopicImport> Topic = Filter(TopicImport) {
             logic state:
               int32 rc = setSubscribeSubscription(getTopicSubscription($topic));
         }
}

/**
 * Get the subscription that matches a topic for
 * topic based subscription.
 *
 * This is a low-level function that allows applications
 * to build custom composites with functionality similar
 * to [Subscribe]. The preference should be to
 * use [Subscribe] where possible.
 *  
 * @param topic Topic to subscribe to.
*/
public rstring getTopicSubscription(rstring topic) {
  appTrc(spl::Trace.debug, "Topic filter:" + topic);
  if (!checkTopicFilter(topic)) {
       appLog(spl::Log.error, "Topic filter is invalid:" + topic);
       assert(true, "Topic filter is invalid:" + topic);
       return "invalid topic filter:" + topic;
  }

  // Wildcard expression is more complicated
  if (findFirst(topic, "+") != -1 || findFirst(topic, "#") != -1) {
      return wildcardExpression(topic);
  }
       
  return "( __spl_exportType == \"topic\" ) && ( __spl_topic == " + makeRStringLiteral(topic) + " )";
}

rstring wildcardExpression(rstring filter) {

    appTrc(spl::Trace.debug, "Wildcard topic filter:" + filter);

    list<rstring> tokens = tokenize(filter, "/", true);
    
    boolean hasHash = findFirst(filter, "#") != -1;
    
    mutable rstring tw = "( ( __spl_exportType == \"topic\" )";
    
    // If there is not a hash wildcard then the topic name
    // must have the same number of levels as the filter
    if (!hasHash) {
       tw += "&& ( __spl_topicLevelCount == " + (rstring) size(tokens) + " )";
    }

    // Single plus, single level, the level count check is sufficient.
    if (filter == "+") {
      tw += ")";
      return tw;
    }

    for (int32 i in range(tokens)) {
      rstring level = tokens[i];
      
      // match anything at this level
      if (level == "+")
          continue;
          
       tw += " && ";

       if (hasHash) {
           tw += "( ";
           tw += "( __spl_topicLevelCount > " + (rstring) i + " )";
           tw += " && ";
       }
       tw += "( __spl_topicLevels["+((rstring) i)+"] == " + makeRStringLiteral(level) + " )";
       if (hasHash) {
           tw += " )";
       }
       
    }
    tw += " )";
    
    return tw;
}

/**
 * Take a subscription and modify it to account for
 * parallel regions in the publisher or subscriber.
 *
 * This is a low-level function that allows applications
 * to build custom composites with functionality similar
 * to [Subscribe] or [FilteredSubscribe]. The preference should be to
 * use [Subscribe] or [FilteredSubscribe] where possible.
 *  
 * @param subscription Base subscription.
*/
public rstring addUDPSubscription(rstring subscription) {
    mutable rstring udpSub = subscription + " && ";

    // Subscribe to non-udp if channel 0
    if (getChannel() == 0)
          udpSub = udpSub + "( (  __spl_channel == -1 ) || ";

     // subscribe to channel
     udpSub = udpSub 
                 // Publisher is UDP
                 + "( "
                 + "  __spl_channel % "
                 + (rstring) getMaxChannels()
                 + " == " 
                 + (rstring) getChannel()
                 + " )";

     if (getChannel() == 0)
       udpSub = udpSub + " )";

     return udpSub;
}

/**
 * Set a subscription expression adding in UDP
 * channel based matching if the subscriber
 * is in a paralel region.
 * @param subscription Subscription to be set on input port
 * connected to `Import` operator.
*/
public stateful int32 setSubscribeSubscription(rstring subscription) {
    // None-UDP or a single width
    mutable rstring actualSub = "";

    // Subsriber is not UDP, subscribe to all publishers
    if (getMaxChannels() == 0 || getMaxChannels() == 1)
        actualSub = subscription;
    else 
        actualSub = addUDPSubscription(subscription);

    int32 rc = setInputPortImportSubscription(actualSub, 0u);
    if (rc != 0) {
       appLog(spl::Log.error, "Failed subscription (" + (rstring) rc
       + "):" + actualSub);
       assert(rc != 0, "Failed subscription (" + (rstring) rc + "):" + actualSub);
    }
    
    return rc;
}

/**
  Check a topic name is valid.
*/
public boolean checkTopicName(rstring topic) {
    if (!checkNoNul(topic))
        return false;
        
    // Check no wildcards
    if (findFirst(topic, "+") != -1)
         return false;
        
    if (findFirst(topic, "#") != -1)
         return false;
    
    return true;
}

boolean checkNoNul(rstring topic) {
   return (findFirst(topic, "\u0000") == -1)
          && (length(topic) !=  0);
}

/**
  Check a topic filter is valid.
*/
public boolean checkTopicFilter(rstring topic) {

    if (!checkNoNul(topic))
        return false;
            
    // Must be the last character
    if (findFirst(topic, "#") != -1) {
       if (topic == "#")
           return true;
           
       if (findFirst(topic, "#") != length(topic) - 1)
           return false;
       
       if (findFirst(topic, "/#") != length(topic) - 2)
           return false;
    }
    
    if (findFirst(topic, "+") == -1)
        return true;
        
    if (topic == "+")
        return true;

    list<rstring> tokens = tokenize(topic, "/", false);
    for (rstring token in tokens) {
       if (token == "+")
           continue;
       if (findFirst(token, "+") != -1)
           return false;
    }
      
    return true;
}

