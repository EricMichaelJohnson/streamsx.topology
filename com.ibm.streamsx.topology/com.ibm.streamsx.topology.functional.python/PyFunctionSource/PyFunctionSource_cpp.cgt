/* Additional includes go here */

#include "splpy.h"
#include "splpy_funcop.h"

using namespace streamsx::topology;

<%SPL::CodeGen::implementationPrologue($model);%>


// Constructor
MY_OPERATOR::MY_OPERATOR() :
    funcop_(NULL),
    function_(NULL)
{
    funcop_ = new SplpyFuncOp(this);

    SplpyGILLock lock;

    PyObject *_module_;
    PyObject *_function_;

<% my $pywrapfunc='iterableSource'; %>
@include "../pywrapfunction.cgt"
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    // Finalization code goes here
    if (function_) {
      SplpyGILLock lock;
      Py_DECREF(function_);
    }

    delete funcop_;
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
  createThreads(1);
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    SplpyOp::prepareToShutdown();
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
  while(!getPE().getShutdownRequested()) {
    
    OPort0Type otuple;

    { // start lock
      SplpyGILLock lock;
      PyObject * pyReturnVar = PyObject_CallObject(function_, NULL);
      if(pyReturnVar == Py_None){
        Py_DECREF(pyReturnVar);
        break;
      } else if(pyReturnVar == 0){
        SplpyGeneral::flush_PyErrPyOut();
        throw;
      }

      long int size = PyBytes_Size(pyReturnVar);
      char * bytes = PyBytes_AsString(pyReturnVar);
      otuple.get___spl_po().setData((const unsigned char *)bytes, size);
      Py_DECREF(pyReturnVar);

    } // end lock

    submit(otuple, 0);
  }

}

<%SPL::CodeGen::implementationEpilogue($model);%>
