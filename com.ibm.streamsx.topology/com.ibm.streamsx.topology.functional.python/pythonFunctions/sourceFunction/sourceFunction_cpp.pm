
package sourceFunction_cpp;
use strict; use Cwd 'realpath';  use File::Basename;  use lib dirname(__FILE__);  use SPL::Operator::Instance::OperatorInstance; use SPL::Operator::Instance::Annotation; use SPL::Operator::Instance::Context; use SPL::Operator::Instance::Expression; use SPL::Operator::Instance::ExpressionTree; use SPL::Operator::Instance::ExpressionTreeEvaluator; use SPL::Operator::Instance::ExpressionTreeVisitor; use SPL::Operator::Instance::ExpressionTreeCppGenVisitor; use SPL::Operator::Instance::InputAttribute; use SPL::Operator::Instance::InputPort; use SPL::Operator::Instance::OutputAttribute; use SPL::Operator::Instance::OutputPort; use SPL::Operator::Instance::Parameter; use SPL::Operator::Instance::StateVariable; use SPL::Operator::Instance::TupleValue; use SPL::Operator::Instance::Window; 
sub main::generate($$) {
   my ($xml, $signature) = @_;  
   print "// $$signature\n";
   my $model = SPL::Operator::Instance::OperatorInstance->new($$xml);
   unshift @INC, dirname ($model->getContext()->getOperatorDirectory()) . "/../impl/nl/include";
   $SPL::CodeGenHelper::verboseMode = $model->getContext()->isVerboseModeOn();
   print '/* Additional includes go here */', "\n";
   print "\n";
   print '#include <Python.h>', "\n";
   print '#include <string>', "\n";
   print '#include <iostream>', "\n";
   print '#include <stdio.h>', "\n";
   print '#include <sstream>', "\n";
   print "\n";
   SPL::CodeGenHelper::implementationPrologueImpl($model,0,9);
   print "\n";
   print '// Constructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::MY_OPERATOR()', "\n";
   print '{', "\n";
   print '  // Initialize the python runtime', "\n";
   print '  SPLAPPTRC(L_INFO, "Starting initialization of python tuplefunction", "python");', "\n";
   print '  if (Py_IsInitialized() == 0) {', "\n";
   print '    Py_InitializeEx(0);', "\n";
   print '    // Initialize the threaded context if it hasn\'t.', "\n";
   print '    if( PyEval_ThreadsInitialized() == 0){', "\n";
   print '      PyEval_InitThreads();', "\n";
   print '      // Calling PyEval_InitThreads grabs the gobal lock.', "\n";
   print '      // Release it immediately, and so this thread can be registered with', "\n";
   print '      // PyGILState_Ensure(). It\'s possible this step is unnecessary, but', "\n";
   print '      // it\'s taken to be safe.', "\n";
   print '      PyEval_SaveThread();', "\n";
   print '    }', "\n";
   print '  }', "\n";
   print "\n";
   print '  // Register this thread with the python runtime. Needed in preparation for', "\n";
   print '  // invoking python runtime functions.', "\n";
   print '  PyGILState_STATE gstate;', "\n";
   print '  gstate = PyGILState_Ensure();', "\n";
   print "\n";
   print '  std::string toolkitDir = getToolkitDirectory();', "\n";
   print "\n";
   print '  // This is a path to the ibmstreams.modulesScript module. The modulesScript', "\n";
   print '  // module is a python script responsible for adding the following locations', "\n";
   print '  // to the Python path of the operator\'s python runtime:', "\n";
   print '  //', "\n";
   print '  // opt/python/streams', "\n";
   print '  // opt/python/packages', "\n";
   print '  // opt/python/modules', "\n";
   print '  //', "\n";
   print '  std::string pythonIncludeModulesDir = toolkitDir + "/opt/python";', "\n";
   print '  std::string appDirectory = getPE().getApplicationDirectory();', "\n";
   print "\n";
   print '  simpleStringCatchErr("import sys");', "\n";
   print "\n";
   print '  // Add the ibmstreams.modulesScript to the Python path', "\n";
   print '  std::stringstream ss;', "\n";
   print '  ss<<"sys.path.append(\\""<<pythonIncludeModulesDir<<"\\")";', "\n";
   print '  simpleStringCatchErr(ss.str().c_str());', "\n";
   print '  ss.str("");', "\n";
   print "\n";
   print '  // Run the modules script, passing in the path to the application directory', "\n";
   print '  simpleStringCatchErr("from ibmstreams.modulesScript import addToolkitModulesToPythonPath");', "\n";
   print '  ss<<"addToolkitModulesToPythonPath(\\""<<appDirectory.c_str()<<"\\")";', "\n";
   print '  simpleStringCatchErr(ss.str().c_str());', "\n";
   print '  ss.str("");', "\n";
   print "\n";
   print '  // Get a reference to a source function object', "\n";
   print '  simpleStringCatchErr("from ibmstreams.function_factory import functionFactory");', "\n";
   print '  simpleStringCatchErr("from ibmstreams.function_types import functionTypes");', "\n";
   print '  PyObject* main = PyImport_AddModule("__main__");', "\n";
   print '  PyObject* globalDictionary = PyModule_GetDict(main);', "\n";
   print '  PyObject* localDictionary = PyDict_New();', "\n";
   print "\n";
   print '  std::string serializedFunc = getParameter_serializedFunc();', "\n";
   print '  std::string functionName = getParameter_functionName();', "\n";
   print '  std::string functionLocation = getParameter_functionLocation();', "\n";
   print "\n";
   print '  ss<<"functionFactory.getFunction(functionTypes.SOURCE_FUNCTION, \\""<<serializedFunc<<"\\",\\""<<functionName<<"\\", \\""<<functionLocation<<"\\")";', "\n";
   print "\n";
   print '  // Obtain the reference', "\n";
   print '  sourceFunction = PyRun_String(ss.str().c_str(), Py_eval_input, globalDictionary, localDictionary);', "\n";
   print '  if(sourceFunction == NULL){', "\n";
   print '      PyErr_Print();', "\n";
   print '      throw;', "\n";
   print '  }', "\n";
   print "\n";
   print '  PyGILState_Release(gstate);', "\n";
   print '  SPLAPPTRC(L_INFO, "Finished initialization of python operator source", "python");', "\n";
   print '}', "\n";
   print "\n";
   print '// Destructor', "\n";
   print 'MY_OPERATOR_SCOPE::MY_OPERATOR::~MY_OPERATOR() ', "\n";
   print '{', "\n";
   print '    // Finalization code goes here', "\n";
   print '}', "\n";
   print "\n";
   print '// Notify port readiness', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::allPortsReady() ', "\n";
   print '{', "\n";
   print '  createThreads(1);', "\n";
   print '}', "\n";
   print ' ', "\n";
   print '// Notify pending shutdown', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::prepareToShutdown() ', "\n";
   print '{', "\n";
   print '    // This is an asynchronous call', "\n";
   print '}', "\n";
   print "\n";
   print '// Processing for source and threaded operators   ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(uint32_t idx)', "\n";
   print '{', "\n";
   print '  while(!getPE().getShutdownRequested()) {', "\n";
   print '    PyGILState_STATE gstate;', "\n";
   print '    gstate = PyGILState_Ensure();', "\n";
   print '    PyObject * pyReturnVar = PyObject_CallObject(sourceFunction, NULL);', "\n";
   print '    if(pyReturnVar == Py_None){', "\n";
   print '      continue;', "\n";
   print '    } else if(pyReturnVar == 0){', "\n";
   print '      PyErr_Print();', "\n";
   print '      throw;', "\n";
   print '    }', "\n";
   print "\n";
   print '    long int size = PyBytes_Size(pyReturnVar);', "\n";
   print '    char * bytes = PyBytes_AsString(pyReturnVar);', "\n";
   print '    SPL::blob serializedObject((const unsigned char *)bytes, size);', "\n";
   print '    OPort0Type op(serializedObject);', "\n";
   print "\n";
   print '    PyGILState_Release(gstate);', "\n";
   print '    submit(op, 0);', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for mutating ports ', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print "\n";
   print '}', "\n";
   print "\n";
   print '// Tuple processing for non-mutating ports', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Tuple const & tuple, uint32_t port)', "\n";
   print '{', "\n";
   print '    // Sample submit code', "\n";
   print '    /* ', "\n";
   print '      OPort0Type otuple;', "\n";
   print '      submit(otuple, 0); // submit to output port 0', "\n";
   print '    */', "\n";
   print '    // Sample cast code', "\n";
   print '    /*', "\n";
   print '    switch(port) {', "\n";
   print '    case 0: { ', "\n";
   print '      IPort0Type const & ituple = static_cast<IPort0Type const&>(tuple);', "\n";
   print '      ...', "\n";
   print '    } break;', "\n";
   print '    case 1: { ', "\n";
   print '      IPort1Type const & ituple = static_cast<IPort1Type const&>(tuple);', "\n";
   print '      ...', "\n";
   print '    } break;', "\n";
   print '    default: ...', "\n";
   print '    }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print '// Punctuation processing', "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::process(Punctuation const & punct, uint32_t port)', "\n";
   print '{', "\n";
   print '    /*', "\n";
   print '      if(punct==Punctuation::WindowMarker) {', "\n";
   print '        // ...;', "\n";
   print '      } else if(punct==Punctuation::FinalMarker) {', "\n";
   print '        // ...;', "\n";
   print '      }', "\n";
   print '    */', "\n";
   print '}', "\n";
   print "\n";
   print 'void MY_OPERATOR_SCOPE::MY_OPERATOR::simpleStringCatchErr(const char * str){', "\n";
   print '  int ret = PyRun_SimpleString(str);', "\n";
   print '  if(ret == -1){', "\n";
   print '    SPLAPPLOG(L_ERROR, "Fatal error while executing the following Python String:"<<std::endl<<str, "python");', "\n";
   print '    PyErr_Print();', "\n";
   print '    throw;', "\n";
   print '  }', "\n";
   print '}', "\n";
   print "\n";
   print "\n";
   SPL::CodeGenHelper::implementationEpilogueImpl($model, 0);
   CORE::exit $SPL::CodeGen::USER_ERROR if ($SPL::CodeGen::sawError);
}
1;
