/* Additional includes go here */

#include "splpy.h"
#include "splpy_funcop.h"

using namespace streamsx::topology;

<%SPL::CodeGen::implementationPrologue($model);%>

@include "../pyspltuple.cgt"
<%
 # Select the Python wrapper function
 my $pywrapfunc= $pystyle_fn . '_in';
%>

// Constructor
MY_OPERATOR::MY_OPERATOR():
   funcop_(NULL),
   pyInStyleObj_(NULL)
{
    funcop_ = new SplpyFuncOp(this, "<%=$pywrapfunc%>");

@include "../pyspltuple_constructor.cgt"
    setupStateHandler();
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
  if (pyInStyleObj_) {
      SplpyGIL lock;
      Py_DECREF(pyInStyleObj_);
  }

  delete funcop_;
}

void MY_OPERATOR::setupStateHandler() 
{/*
  SplpyGIL lock;
  // Test whether funcop_ is a class
  Py_INCREF(funcop_->callable());
  PyObject * rv = SplpyGeneral::callFunction("streamsx.spl.runtime", "_splpy_is_class", funcop_->callable(), (PyObject*)0);
  if (PyObject_IsTrue(rv)) {
    std::cout << "A class" << std::endl;
  }
  else {
    std::cout << "Not a class" << std::endl;
  }
  Py_DECREF(rv);
*/
}

// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    funcop_->prepareToShutdown();
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
try {
@include "../pyspltuple2value.cgt"

  streamsx::topology::Splpy::pyTupleForEach(funcop_->callable(), value);
} catch (const streamsx::topology::SplpyExceptionInfo& excInfo) {
  SPLPY_OP_HANDLE_EXCEPTION_INFO_GIL(excInfo);
}
 
}

<%SPL::CodeGen::implementationEpilogue($model);%>
