/* Additional includes go here */

#include "splpy.h"
#include "splpy_funcop.h"

using namespace streamsx::topology;

<%SPL::CodeGen::implementationPrologue($model);%>

@include "../pyspltuple.cgt"
<%
 # Select the Python wrapper function
 my $pywrapfunc= $pystyle_fn . '_in';
%>

// Constructor
MY_OPERATOR::MY_OPERATOR() :
   funcop_(NULL),
   pyInStyleObj_(NULL),
   crContext(this)
{
    funcop_ = new SplpyFuncOp(this, "<%=$pywrapfunc%>");

@include "../pyspltuple_constructor.cgt"
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    if (pyInStyleObj_) {
      SplpyGIL lock;
      Py_DECREF(pyInStyleObj_);
    }

    delete funcop_;
}

void MY_OPERATOR::prepareToShutdown() 
{
    SPLPY_AUTO_OP_LOCK();
    funcop_->prepareToShutdown();
}

void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
    bool passed = false;
    SPLPY_AUTO_OP_LOCK();
    try {

@include "../pyspltuple2value.cgt"

        passed = streamsx::topology::Splpy::pyTupleFilter(funcop_->callable(), value);
    } catch (const streamsx::topology::SplpyExceptionInfo& excInfo) {
        SPLPY_OP_HANDLE_EXCEPTION_INFO_GIL(excInfo);
        return;
    }
    if (passed)
         submit(tuple, 0);
}

void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
   forwardWindowPunctuation(punct);
}

<%SPL::CodeGen::implementationEpilogue($model);%>
