/* Additional includes go here */
#include <Python.h>
#include <string>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>

<%SPL::CodeGen::implementationPrologue($model);%>

<%
 my $cmnDir = $model->getContext()->getToolkitDirectory()."/opt/.__splpy/common/";

 require "splpy_operator.pm";
 use Switch;
 require $cmnDir."/spl_python.pm";

 my $module = splpy_Module();
 my $functionName = splpy_FunctionName();
 my $fixedParam = splpy_FixedParam();
 
 my $iport = $model->getInputPortAt(0);
 my $itupleType = $iport->getSPLTupleType();
 my @inames = SPL::CodeGen::Type::getAttributeNames($itupleType);
 my @itypes = SPL::CodeGen::Type::getAttributeTypes($itupleType);

 my $inputAttrs2Py = $iport->getNumberOfAttributes();
 if ($fixedParam != -1) {
    $inputAttrs2Py = $fixedParam;
 }
 
  my $ituple = $iport->getCppTupleName();
%>

// Constructor
MY_OPERATOR::MY_OPERATOR()
{
@include  "../../opt/.__splpy/common/py_constructor.cgt"
}

// Destructor
MY_OPERATOR::~MY_OPERATOR() 
{
    // Finalization code goes here
    // Py_Finalize();
}

// Notify port readiness
void MY_OPERATOR::allPortsReady() 
{
    // Notifies that all ports are ready. No tuples should be submitted before
    // this. Source operators can use this method to spawn threads.

    /*
      createThreads(1); // Create source thread
    */
}
 
// Notify pending shutdown
void MY_OPERATOR::prepareToShutdown() 
{
    // This is an asynchronous call
}

// Processing for source and threaded operators   
void MY_OPERATOR::process(uint32_t idx)
{
    // A typical implementation will loop until shutdown
    /*
      while(!getPE().getShutdownRequested()) {
          // do work ...
      }
    */
}

// Tuple processing for mutating ports 
void MY_OPERATOR::process(Tuple & tuple, uint32_t port)
{
    // Sample submit code
    /* 
      submit(otuple, 0); // submit to output port 0
    */
}

// Tuple processing for non-mutating ports
void MY_OPERATOR::process(Tuple const & tuple, uint32_t port)
{
   IPort0Type const & <%=$ituple%> = static_cast<IPort0Type const &>(tuple);

    PyGILState_STATE gstate;
    gstate = PyGILState_Ensure();
  
    PyObject * pyTuple = PyTuple_New(<%=$inputAttrs2Py%>); 
    PyObject *pyValue;
<%
     for (my $i = 0; $i < $inputAttrs2Py; ++$i) {
         print convertToPythonValue($ituple, $i, $itypes[$i], $inames[$i]);
     }
%>
  
    PyObject * pyReturnNone = PyObject_CallObject(function_, pyTuple);

    Py_DECREF(pyTuple);
    if (pyReturnNone == NULL) {
        SPLAPPLOG(L_ERROR, "Fatal error: function failed: " << "<%=$functionName%>", "python");
        throw;
    }

    Py_DECREF(pyReturnNone);
    PyGILState_Release(gstate); 
}

// Punctuation processing
void MY_OPERATOR::process(Punctuation const & punct, uint32_t port)
{
    /*
      if(punct==Punctuation::WindowMarker) {
        // ...;
      } else if(punct==Punctuation::FinalMarker) {
        // ...;
      }
    */
}

<%SPL::CodeGen::implementationEpilogue($model);%>

