<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="Python Application API"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_page"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>Python Application API</title>
</head>
<body id="spldoc_page">


<h1 class="title topictitle1">Python Application API</h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; <a class="xref" href="tk$com.ibm.streamsx.topology.html">com.ibm.streamsx.topology 1.2.5.alpha</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.topology.python.html">com.ibm.streamsx.topology.python</a> &gt; Python Application API</p>

</div>


<div class="section">
<p class="p">Develop IBM Streams applications with Python.
</p>

<p class="p"><strong class="ph b">Alpha version, basic functionality</strong>
</p>

<p class="p">This is intended as a preview of the intended direction, functionality is limited.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Overview
</h2>

<p class="p">A functional api to develop streaming applications for IBM Streams using Python. Streams are defined, transformed and sinked (terminated) using Python functions. The return of a function determines the content of the stream. Tuples on a stream are Python objects, a stream may contain different types of objects.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Prerequites
</h2>

<div class="p">
<ul class="ul">
<li class="li"> Install and configure IBM Streams Version 4.0.0 (or later).</li>

<li class="li"> Install CPython 3.5.0 (or later).  Testing has been performed with Python 3.5.1.  Python is assumed to be installed in the default location (<tt class="ph tt">/usr/local</tt>).</li>

<li class="li"> Download and extract the IBM Streams Topology Toolkit, which includes the Python Application API.   Include the fully qualified path of the <tt class="ph tt">com.ibm.streamsx.topology/opt/python/packages</tt> directory in the PYTHONPATH environment variable.</li>

</ul>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Sample HelloWorld Application
</h2>

<p class="p">Example code that builds and then submits a Hello World topology.
</p>

<div class="p">
<pre class="pre codeblock">
import mymodule;
from streamsx.topology.topology import *
import streamsx.topology.context

topo = Topology("HelloWorld")
hw = topo.source(mymodule.hello_world)
hw.sink(print)
streamsx.topology.context.submit("STANDALONE", topo.graph)
</pre>


</div>

<p class="p">The <tt class="ph tt">source</tt> function is passed a callable that returns an <tt class="ph tt">Iterable</tt>, in this case <tt class="ph tt">mymodule.hello_world</tt>.
</p>

<div class="p">
<pre class="pre codeblock">
def hello_world() :
    return ["Hello", "World!"]
</pre>


</div>

<p class="p">The callable will be called when the application starts, and the SPL runtime will create an iterator from the returned value. Then each value returned from the iterator will be sent on the stream.
</p>

<p class="p">The <tt class="ph tt">sink</tt> function is passed a callable that will be called for each tuple on the stream, in this case the builtin <tt class="ph tt">print</tt> function.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">User-supplied functions to operations
</h2>

<div class="p">Operations such as <tt class="ph tt">source</tt> and <tt class="ph tt">sink</tt> accept a callable as input.  The callable must be one of the following:
<ul class="ul">
<li class="li"> the name of a built-in function</li>

<li class="li"> the name of a function defined at the top level of a module</li>

<li class="li"> an instance of a callable class defined at the top level of a module that implements the method <tt class="ph tt">__call__</tt> and is picklable.  Using a callable class allows state information such as user-defined parameters to be stored during class initialization and utilized when the instance is called.</li>

</ul>

</div>

<div class="p">The modules containing the callables, along with third-party libraries required by the modules, are copied into the Streams Application Bundle (sab file).
<ul class="ul">
<li class="li"> Dependent libraries can be individual modules or packages.</li>

<li class="li"> Dependent libraries can be installed in site packages, or not installed and simply reside in a directory in the Python search path</li>

<li class="li"> Platform-dependent (native) libaries in lib-dynload are not copied into the bundle</li>

</ul>

</div>

<div class="p">Limitations on callable inputs to operations:
<ul class="ul">
<li class="li"> Callables must be defined in a module file.</li>

<li class="li"> Callables must not be dynamically created nor anonymous.</li>

<li class="li"> Callables must not be defined in the <tt class="ph tt">__main__</tt> module.  They must be defined in a separate module.</li>

<li class="li"> Importing modules that contain user-defined functions with importlib is unsupported.  The PYTHONPATH or sys.path must contain the directory where modules to import are located.</li>

<li class="li"> Importing modules that contain user-defined functions from zip/egg/wheel files is unsupported.</li>

</ul>

</div>

<div class="p">To avoid name conflicts, do not create modules with the same name as 
<ul class="ul">
<li class="li"> <tt class="ph tt">streamsx</tt> which is used by the Python Application API</li>

<li class="li"> built-in or standard library module names</li>

</ul>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Streams functions 
</h2>

<div class="p">
<ul class="ul">
<li class="li"> <tt class="ph tt">source(self, func)</tt> function on <tt class="ph tt">Topology</tt>
<p class="p">  Fetches information from an external system and presents that information as a stream.   Takes a zero-argument callable that returns an iterable of tuples.   Each tuple that is not None from the iterator returned   from iter(func()) is present on the returned stream.
</p>

<p class="p">  param <tt class="ph tt">func</tt>: A zero-argument callable that returns an iterable of tuples.   A tuple is represented as a Python object that must be picklable.
</p>

<p class="p">  return: A Stream whose tuples are the result of the output obtained by invoking the provided callable.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">subscribe(self, topic, schema=CommonSchema.Python)</tt> function on <tt class="ph tt">Topology</tt>
</p>

<p class="p">  Subscribe to a topic published by other Streams applications.   A Streams application may publish a stream to allow other   applications to subscribe to it. A subscriber matches a   publisher if the topic and schema match.
</p>

<p class="p">  See <a class="xref" href="ns$com.ibm.streamsx.topology.topic.html">namespace:com.ibm.streamsx.topology.topic</a> for more details.
</p>

<p class="p">  param <tt class="ph tt">topic</tt>: Topic to subscribe to.   param <tt class="ph tt">schema</tt>: Schema to subscriber to. Defaults to CommonSchema.Python representing Python objects.   return: A Stream whose tuples have been published to the topic by other Streams applications.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">sink(self, func)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Sends information as a stream to an external system.   Takes a user provided callable that does not return a value.
</p>

<p class="p">  param <tt class="ph tt">func</tt>: A callable that takes a single parameter for the tuple and returns None.   The callable is invoked for each incoming tuple.  
</p>

<p class="p">  return: None
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">filter(self, func)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Filters tuples from a stream using the supplied callable <tt class="ph tt">func</tt>.   For each tuple on the stream the callable is called passing   the tuple, if the callable return evalulates to true the   tuple will be present on the returned stream, otherwise   the tuple is filtered out.
</p>

<p class="p">  param <tt class="ph tt">func</tt>: A callable that takes a single parameter for the tuple, and returns True or False.   If True, the tuple is included on the returned stream.  If False, the tuple is filtered out.   The callable is invoked for each incoming tuple.
</p>

<p class="p">  return: A Stream containing tuples that have not been filtered out.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">transform(self, func)</tt> or <tt class="ph tt">map(self, func)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Transforms each tuple from this stream into 0 or 1 tuples using the supplied callable <tt class="ph tt">func</tt>.   For each tuple on this stream, the returned stream will contain a tuple   that is the result of the callable when the return is not None.   If the callable returns None then no tuple is submitted to the returned    stream.
</p>

<p class="p">  param <tt class="ph tt">func</tt>: A callable that takes a single parameter for the tuple, and returns a tuple or None.   The callable is invoked for each incoming tuple.
</p>

<p class="p">  return: A Stream containing transformed tuples.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">multi_transform(self, func)</tt> or <tt class="ph tt">flat_map(self, func)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Transforms each tuple from this stream into 0 or more tuples using the supplied callable <tt class="ph tt">func</tt>.    For each tuple on this stream, the returned stream will contain all non-None tuples from   the iterable.   Tuples will be added to the returned stream in the order the iterable   returns them.   If the return is None or an empty iterable then no tuples are added to   the returned stream.
</p>

<p class="p">  param <tt class="ph tt">func</tt>: A callable that takes a single parameter for the tuple, and returns an iterable of tuples or None.   The callable must return an iterable or None, otherwise a TypeError is raised.   The callable is invoked for each incoming tuple.
</p>

<p class="p">  return: A Stream containing transformed tuples.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">isolate(self)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Guarantees that the upstream operation will run in a separate process from the downstream operation when    the application is executed in distributed mode.
</p>

<p class="p">  return: Stream
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">low_latency(self)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  The function is guaranteed to run in the same process as the   upstream Stream function. All streams that are created from the returned stream    are also guaranteed to run in the same process until end_low_latency()    is called.
</p>

<p class="p">  return: Stream
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">end_low_latency(self)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Returns a Stream that is no longer guaranteed to run in the same process   as the calling stream.
</p>

<p class="p">  return: Stream
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">union(self, streamSet)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  The Union operator merges the outputs of the streams in the set into a single stream.
</p>

<p class="p">  param <tt class="ph tt">streamSet</tt> - Set of streams outputs to merge
</p>

<p class="p">  returns: Stream
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">parallel(self, width, routing=None, func=None)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Parallelizes the stream into <tt class="ph tt">width</tt> parallel channels.   Tuples are routed to parallel channels such that an even distribution is maintained.   Each parallel channel can be thought of as being assigned its own thread.   As such, each parallelized stream function are separate instances and operate independently from one another.
</p>

<p class="p">  <tt class="ph tt">parallel</tt> will only parallelize the stream operations performed after the call to <tt class="ph tt">parallel</tt> and before the call to <tt class="ph tt">end_parallel</tt>
</p>

<p class="p">  Parallel regions aren't required to have an output stream, and thus may be used as sinks.   In other words, a parallel sink is created by calling <tt class="ph tt">parallel</tt> and creating a sink operation.   It is not necessary to invoke <tt class="ph tt">end_parallel</tt> on parallel sinks.
</p>

<p class="p">  Nested parallelism is not currently supported.   A call to <tt class="ph tt">parallel</tt> should never be made immediately after another call to <tt class="ph tt">parallel</tt> without having an <tt class="ph tt">end_parallel</tt> in between.
</p>

<p class="p">  Every call to <tt class="ph tt">end_parallel</tt> must have a call to <tt class="ph tt">parallel</tt> preceding it.
</p>

<p class="p">  param <tt class="ph tt">width</tt>: degree of parallelism
</p>

<div class="p">  param: <tt class="ph tt">routing</tt> - denotes what type of tuple routing to use. 
<ul class="ul">
<li class="li"> ROUND_ROBIN: delivers tuples in round robin fashion to downstream operators (Default)</li>

<li class="li"> HASH_PARTIONED: delivers to downstream operators based on the hash of the tuples being sent or if a function is provided the function will be called to provide the hash</li>

</ul>

</div>

<p class="p">  param: <tt class="ph tt">func</tt> - (Optional) Function called when HASH_PARTIONED routing is specified. The function provides an int32 value to be used as the hash that determines the tuple routing to downstream operators
</p>

<p class="p">  return: Stream whose subsequent processing will occur on <tt class="ph tt">width</tt> channels.
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">end_parallel(self)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Ends a parallel region by merging the channels into a single stream
</p>

<p class="p">  return: A Stream for which subsequent transformations are no longer parallelized
</p>
</li>

<li class="li">
<p class="p"> <tt class="ph tt">publish(self, topic, schema=schema.CommonSchema.Python)</tt> function on <tt class="ph tt">Stream</tt>
</p>

<p class="p">  Publish this stream on a topic for other Streams applications to subscribe to.   A Streams application may publish a stream to allow other   applications to subscribe to it. A subscriber matches a   publisher if the topic and schema match.
</p>

<p class="p">  See <a class="xref" href="ns$com.ibm.streamsx.topology.topic.html">namespace:com.ibm.streamsx.topology.topic</a> for more details.
</p>

<p class="p">  param <tt class="ph tt">topic</tt>: Topic to publish this stream to.   param: <tt class="ph tt">schema</tt>: Schema to publish. Defaults to CommonSchema.Python representing Python objects.
</p>

<p class="p">  return: None
</p>
</li>

</ul>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Sample Transform Application
</h2>

<p class="p">Example code that builds and then submits a simple topology.
</p>

<div class="p">
<pre class="pre codeblock">
from streamsx.topology.topology import Topology
import streamsx.topology.context
import transform_sample_functions;

topo = Topology("transform_sample")
source = topo.source(transform_sample_functions.int_strings_transform)
i1 = source.transform(transform_sample_functions.string_to_int)
i2 = i1.transform(transform_sample_functions.AddNum(17))
i2.print()
streamsx.topology.context.submit("STANDALONE", topo.graph)
</pre>


</div>

<p class="p">The <tt class="ph tt">source</tt> function is passed a function that returns an <tt class="ph tt">Iterable</tt>, in this case <tt class="ph tt">transform_sample_functions.int_strings_transform</tt>.
</p>

<div class="p">
<pre class="pre codeblock">
def int_strings_transform():
    return ["325", "457", "9325"]
</pre>


</div>

<p class="p">The first <tt class="ph tt">transform</tt> function is passed a function that returns an integer converted from the string object, in this case <tt class="ph tt">transform_sample_functions.string_to_int</tt>.
</p>

<div class="p">
<pre class="pre codeblock">
def string_to_int(t):
    return int(t)
</pre>


</div>

<p class="p">The second <tt class="ph tt">transform</tt> function is passed an instance of a callable class that adds 17 to the integer, in this case <tt class="ph tt">transform_sample_functions.AddNum(17)</tt>.
</p>

<div class="p">
<pre class="pre codeblock">
class AddNum:
    def __init__(self, increment):
        self.increment = increment  
    def __call__(self, tuple):
        return tuple + self.increment
</pre>


</div>

</div>

<div class="section"><h2 class="title sectiontitle">Running the Sample Transform Application
</h2>

<p class="p">When building the topology the directory <tt class="ph tt">com.ibm.streamsx.topology/opt/python/packages</tt> must be in <tt class="ph tt">$PYTHONPATH</tt>.
</p>

<p class="p">The sample <tt class="ph tt">transform_sample.py</tt> can be found under <tt class="ph tt">samples/python/topology/simple</tt>. After updating the PYTHONPATH, the sample can be executed using <tt class="ph tt">python3 transform_sample.py</tt>.
</p>

<div class="p">Sample output:
<pre class="pre codeblock">
342
474
9342
</pre>


</div>

</div>

<div class="section"><h2 class="title sectiontitle">Context Types
</h2>

<div class="p">Only submission using <tt class="ph tt">DISTRIBUTED</tt>, <tt class="ph tt">BUNDLE</tt> and <tt class="ph tt">STANDALONE</tt> context type are supported.
<ul class="ul">
<li class="li"> <tt class="ph tt">DISTRIBUTED</tt> converts the application to an SPL graph, compiles it and submits it as a Streams application bundle to a Streams instance. The bundle is submitted using <tt class="ph tt">streamtool</tt> which must be setup to submit without requiring authentication input.</li>

<li class="li"> <tt class="ph tt">BUNDLE</tt> converts the application to an SPL graph and compiles it, producing a SPL application bundle (.sab file).  The application is executed separately by submitting the bundle to an IBM Streams instance as a distributed application.  A bundle can be submitted to an IBM Streams instance using <tt class="ph tt">streamtool submitjob</tt>, the IBM Streams Console, or IBM Streams JMX API.</li>

<li class="li"> <tt class="ph tt">STANDALONE</tt> converts the application to an SPL graph, compiles it and executes it as an IBM Streams standalone application.  The standalone execution is spawned as a separate process.</li>

</ul>

</div>

<p class="p">Limited testing has been performed to build an application using DISTRIBUTED and BUNDLE.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Future Items
</h2>

<p class="p">Future items that need to be supported
</p>

<div class="p">
<ul class="ul">
<li class="li"> lambda functions</li>

<li class="li"> dynamic functions</li>

<li class="li"> functions in packages</li>

<li class="li"> IBM Streams application features, such as windowing, etc.</li>

<li class="li"> ...</li>

</ul>

</div>

</div>

</div>


</body>
</html>