<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="Publish-subscribe Overview"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_page"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>Publish-subscribe Overview</title>
</head>
<body id="spldoc_page">


<h1 class="title topictitle1">Publish-subscribe Overview</h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; <a class="xref" href="tk$com.ibm.streamsx.topology.html">com.ibm.streamsx.topology 1.1.6</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.topology.topic.html">com.ibm.streamsx.topology.topic</a> &gt; Publish-subscribe Overview</p>

</div>


<div class="section">
<p class="p">Applications can publish streams to topics which can then be subscribed to by other applications (or even the same application). Publish-subscribe works across applications written in SPL and those written using application APIs provided by this toolkit.
</p>

<p class="p">A subscriber matches a publisher if their topic and stream type are an exact match to that of the publisher. It is recommended that a single stream type is used for a topic.
</p>

<p class="p">A topic is a <tt class="ph tt">rstring</tt> value (encoded with UTF-8), it is recommended that the <a class="xref" href="http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#appendix-a">MQTT topic style</a> is used, and that topic names do not include wild-cards. Future versions may support subscription by MQTT style wild cards (e.g. <tt class="ph tt">cdr/voice/*</tt>).
</p>

<p class="p">Publish-subscribe is a many to many relationship, any number of publishers can publish to the same topic and stream type, and there can be many subscribers to a topic.
</p>

<p class="p">For example a telco ingest application may process Call Detail Records from network switches and publish processed records on multiple topics, <tt class="ph tt">cdr/voice/normal</tt>, <tt class="ph tt">cdr/voice/dropped</tt>, <tt class="ph tt">cdr/sms</tt>, etc. by publishing each processed stream with its own topic. Then a dropped call analytic application would subscribe to the <tt class="ph tt">cdr/voice/dropped</tt> topic.
</p>

<p class="p">Publish-subscribe is dynamic, using IBM Streams dynamic connections, an application can be submitted that subscribes to topics published by other already running applications. Once the new application has initialized, it will start consuming tuples from published streams from existing applications. And any stream the new application publishes will be subscribed to by existing applications where the topic and stream type matches.
</p>

<p class="p">An application only receives tuples that are published while it is connected, thus tuples are lost during a connection failure.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">SPL Publish-Subscribe
</h2>

<p class="p">An SPL application uses <a class="xref" href="spl$com.ibm.streamsx.topology.topic$topics.html#spldoc_compilationunit__composite_operator__Publish">Publish</a> to publish a stream to a topic, and <a class="xref" href="spl$com.ibm.streamsx.topology.topic$topics.html#spldoc_compilationunit__composite_operator__Subscribe">Subscribe</a> to subscribe to a topic.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Java &amp; Scala Publish-Subscribe
</h2>

<p class="p">A Java application uses <a class="xref" href="../../../javadoc/com/ibm/streamsx/topology/TStream.html#publish(java.lang.String)">TStream.publish(topic)</a> to publish streams.
</p>

</div>

<div class="section"><h2 class="title sectiontitle">Interchangeable Stream Types
</h2>

<p class="p">Published streams can be subscribed to by IBM Streams applications written in different languages, by ensuring common stream types (schemas).
</p>

<div class="p">
<ul class="ul">
<li class="li"> SPL Tuples
<ul class="ul">
<li class="li"> SPL : SPL schema of the stream.</li>

<li class="li"> Java : <a class="xref" href="../../../javadoc/com/ibm/streamsx/topology/spl/SPLStream.html">SPLStream</a> with a schema matching the SPL schema.</li>

<li class="li"> Scala : <tt class="ph tt">com.ibm.streamsx.topology.spl.SPLStream</tt> with a schema matching the SPL schema.</li>

</ul>
</li>

<li class="li"> JSON tuples
<ul class="ul">
<li class="li"> SPL : <a class="xref" href="spl$com.ibm.streamsx.topology$types.html#spldoc_compilationunit__type__Json">com.ibm.streamsx.topology::Json</a>  </li>

<li class="li"> Java: <tt class="ph tt">TStream&lt;JSONObject&gt;</tt>.     See <a class="xref" href="../../../javadoc/com/ibm/streamsx/topology/json/package-summary.html#package_description">com.ibm.streamsx.topology.json</a>.</li>

<li class="li"> Scala: <tt class="ph tt">TStream[JSONObject]</tt></li>

</ul>
</li>

<li class="li"> String tuples
<ul class="ul">
<li class="li"> SPL : <a class="xref" href="spl$com.ibm.streamsx.topology$types.html#spldoc_compilationunit__type__String">com.ibm.streamsx.topology::String</a></li>

<li class="li"> Java: <tt class="ph tt">TStream&lt;String&gt;</tt></li>

<li class="li"> Scala: <tt class="ph tt">TStream[String]</tt></li>

</ul>
</li>

<li class="li"> XML tuples
<ul class="ul">
<li class="li"> SPL : <a class="xref" href="spl$com.ibm.streamsx.topology$types.html#spldoc_compilationunit__type__XML">com.ibm.streamsx.topology::XML</a></li>

<li class="li"> Java: <tt class="ph tt">TStream&lt;com.ibm.streams.operator.types.XML&gt;</tt></li>

<li class="li"> Java: <tt class="ph tt">TStream[com.ibm.streams.operator.types.XML]</tt></li>

</ul>
</li>

<li class="li"> Binary tuples
<ul class="ul">
<li class="li"> SPL : <a class="xref" href="spl$com.ibm.streamsx.topology$types.html#spldoc_compilationunit__type__Blob">com.ibm.streamsx.topology::Blob</a></li>

<li class="li"> Java: <tt class="ph tt">TStream&lt;com.ibm.streams.operator.types.Blob&gt;</tt></li>

<li class="li"> Scala: <tt class="ph tt">TStream[com.ibm.streams.operator.types.Blob]</tt></li>

</ul>
</li>

</ul>

</div>

</div>

<div class="section"><h2 class="title sectiontitle">Behavior with parallel regions
</h2>

<p class="p">Topic publish-subscribe model was changed for releases 1.1.X to have intuitive and defined behavior when the publisher or subscriber is in a parallel region (with width &gt; 1).
</p>

<div class="p"><em class="ph i">It is recommended that if either publisher or subscriber is in a parallel region then applications should be compiled against released versions of this toolkit</em>:
<ul class="ul">
<li class="li"> 1.1.x with x &gt;= 6</li>

<li class="li"> 1.2.x with x &gt;= 6</li>

<li class="li"> or any new version in future</li>

</ul>

</div>

<p class="p">The intuitive case is that parallel regions are used to partition tuple processing across the channels, so that each channel processes a subset of the tuples, and each tuple is processed by a single channel.
</p>

<p class="p">Any subscriber connecting to a publisher must then process the complete output from the publisher and only process each published tuple only once. For example if a publisher is in a parallel region with width three, then there are three published channels. A connecting subscriber with width two will have two subscribing channels. Each published channel must connect to a single subscribing channel, and in this case one subscriber channel will connect to two published channels and the other to the remaining published channel.
</p>

<div class="p">

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table" frame="border" border="1" rules="all"><caption><span class="tablecap">Table 1. Publish-Subscribe with Parallel Regions
</span></caption>



<thead class="thead" align="left">
<tr class="row">
<th class="entry" colspan="1" valign="top" id="d637e283">
<p class="p">Publisher
</p>

</th>

<th class="entry" colspan="1" valign="top" id="d637e289">
<p class="p">Subscriber
</p>

</th>

<th class="entry" colspan="1" valign="top" id="d637e295">
<p class="p">Behavior
</p>

</th>

</tr>

</thead>

<tbody class="tbody">
<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">not-parallel</em>
</p>

</td>

<td class="entry" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">not-parallel</em>
</p>

</td>

<td class="entry" rowspan="2" colspan="1" valign="top" headers="d637e295 ">
<p class="p">Single connection between the publisher and subscriber containing all the tuples
</p>

</td>

</tr>

<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">parallel(1)</em>
</p>

</td>

<td class="entry" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">parallel(1)</em>
</p>

</td>

</tr>

<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">not-parallel</em>
</p>

</td>

<td class="entry" rowspan="2" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">parallel(N)</em>
</p>

<p class="p">  <em class="ph i">N &gt; 1</em>
</p>

</td>

<td class="entry" rowspan="2" colspan="1" valign="top" headers="d637e295 ">
<p class="p">One and only one of the N subscribers connects to the single publisher and thus the subscriber region correctly processes the tuples once.  Note that which subscriber channel processes the single published channel is not defined, it could be any of 0,1,...,N-1.
</p>

</td>

</tr>

<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">parallel(1)</em>
</p>

</td>

</tr>

<tr class="row">
<td class="entry" rowspan="2" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">parallel(M)</em>
</p>

<p class="p"><em class="ph i">M &gt; 1</em>
</p>

</td>

<td class="entry" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">not-parallel</em>
</p>

</td>

<td class="entry" rowspan="2" colspan="1" valign="top" headers="d637e295 ">
<p class="p">Single subscriber connects to each of the M publishers so that the subscriber region will process all the the published tuples once.
</p>

</td>

</tr>

<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">parallel(1)</em>
</p>

</td>

</tr>

<tr class="row">
<td class="entry" colspan="1" valign="top" headers="d637e283 ">
<p class="p"><em class="ph i">parallel(M)</em> <em class="ph i">M &gt; 1</em>
</p>

</td>

<td class="entry" colspan="1" valign="top" headers="d637e289 ">
<p class="p"><em class="ph i">parallel(N)</em> <em class="ph i">N &gt; 1</em>
</p>

</td>

<td class="entry" colspan="1" valign="top" headers="d637e295 ">
<p class="p">Each published channel is connected to a single subscribe channel with channel number <tt class="ph tt">publish channel % N</tt>. Thus the subscriber region processes the tuples once. 
</p>

</td>

</tr>

</tbody>

</table>
</div>

</div>

<p class="p"><strong class="ph b">Note</strong> <em class="ph i">It's important to remember there may be multiple applications publishing and/or subscribing to the same topic and thus publish/subscribe must work in all combinations, e.g. there may be a publishers to the same topic of non-parallel, parallel(5) and parallel(3), and subscribers of non-parallel and parallel(7). This is especially true in a microservices style architecture where analytic applications may come and go and there may not be pre-assigned agreement that publisher and subscribers will have matching channel numbers.</em>
</p>

</div>

</div>


</body>
</html>